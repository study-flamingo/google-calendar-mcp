{
  "version": 3,
  "sources": ["../src/auth/client.ts", "../src/auth/utils.ts", "../src/auth/server.ts", "../src/auth/tokenManager.ts", "../src/auth-server.ts"],
  "sourcesContent": ["import { OAuth2Client } from 'google-auth-library';\r\nimport * as fs from 'fs/promises';\r\nimport { getKeysFilePath } from './utils.js';\r\n\r\nexport async function initializeOAuth2Client(): Promise<OAuth2Client> {\r\n  try {\r\n    const keysContent = await fs.readFile(getKeysFilePath(), \"utf-8\");\r\n    const keys = JSON.parse(keysContent);\r\n\r\n    const { client_id, client_secret, redirect_uris } = keys.installed;\r\n\r\n    // Use the first redirect URI as the default for the base client\r\n    return new OAuth2Client({\r\n      clientId: client_id,\r\n      clientSecret: client_secret,\r\n      redirectUri: redirect_uris[0], \r\n    });\r\n  } catch (error) {\r\n    throw new Error(`Error loading OAuth keys: ${error instanceof Error ? error.message : error}`);\r\n  }\r\n}\r\n\r\nexport async function loadCredentials(): Promise<{ client_id: string; client_secret: string }> {\r\n  try {\r\n    const keysContent = await fs.readFile(getKeysFilePath(), \"utf-8\");\r\n    const keys = JSON.parse(keysContent);\r\n    const { client_id, client_secret } = keys.installed;\r\n    if (!client_id || !client_secret) {\r\n        throw new Error('Client ID or Client Secret missing in keys file.');\r\n    }\r\n    return { client_id, client_secret };\r\n  } catch (error) {\r\n    throw new Error(`Error loading credentials: ${error instanceof Error ? error.message : error}`);\r\n  }\r\n} ", "import * as path from 'path';\r\nimport { fileURLToPath } from 'url';\r\n\r\n// Helper to get the project root directory reliably\r\nfunction getProjectRoot(): string {\r\n  const __dirname = path.dirname(fileURLToPath(import.meta.url)); \r\n  // In build output (e.g., build/bundle.js), __dirname is .../build\r\n  // Go up ONE level to get the project root\r\n  const projectRoot = path.join(__dirname, \"..\"); // Corrected: Go up ONE level\r\n  return path.resolve(projectRoot); // Ensure absolute path\r\n}\r\n\r\n// Returns the absolute path for the saved token file.\r\nexport function getSecureTokenPath(): string {\r\n  const projectRoot = getProjectRoot();\r\n  const tokenPath = path.join(projectRoot, \".gcp-saved-tokens.json\");\r\n  return tokenPath; // Already absolute from getProjectRoot\r\n}\r\n\r\n// Returns the absolute path for the GCP OAuth keys file.\r\nexport function getKeysFilePath(): string {\r\n  const projectRoot = getProjectRoot();\r\n  const keysPath = path.join(projectRoot, \"gcp-oauth.keys.json\"); \r\n  return keysPath; // Already absolute from getProjectRoot\r\n} ", "import express from 'express';\r\nimport { OAuth2Client } from 'google-auth-library';\r\nimport { TokenManager } from './tokenManager.js';\r\nimport http from 'http';\r\nimport open from 'open';\r\nimport { loadCredentials } from './client.js';\r\n\r\nexport class AuthServer {\r\n  private baseOAuth2Client: OAuth2Client; // Used by TokenManager for validation/refresh\r\n  private flowOAuth2Client: OAuth2Client | null = null; // Used specifically for the auth code flow\r\n  private app: express.Express;\r\n  private server: http.Server | null = null;\r\n  private tokenManager: TokenManager;\r\n  private portRange: { start: number; end: number };\r\n  public authCompletedSuccessfully = false; // Flag for standalone script\r\n\r\n  constructor(oauth2Client: OAuth2Client) {\r\n    this.baseOAuth2Client = oauth2Client;\r\n    this.tokenManager = new TokenManager(oauth2Client);\r\n    this.app = express();\r\n    this.portRange = { start: 3000, end: 3004 };\r\n    this.setupRoutes();\r\n  }\r\n\r\n  private setupRoutes(): void {\r\n    this.app.get('/', (req, res) => {\r\n      // Generate the URL using the active flow client if available, else base\r\n      const clientForUrl = this.flowOAuth2Client || this.baseOAuth2Client;\r\n      const scopes = ['https://www.googleapis.com/auth/calendar'];\r\n      const authUrl = clientForUrl.generateAuthUrl({\r\n        access_type: 'offline',\r\n        scope: scopes,\r\n        prompt: 'consent'\r\n      });\r\n      res.send(`<h1>Google Calendar Authentication</h1><a href=\"${authUrl}\">Authenticate with Google</a>`);\r\n    });\r\n\r\n    this.app.get('/oauth2callback', async (req, res) => {\r\n      const code = req.query.code as string;\r\n      if (!code) {\r\n        res.status(400).send('Authorization code missing');\r\n        return;\r\n      }\r\n      // IMPORTANT: Use the flowOAuth2Client to exchange the code\r\n      if (!this.flowOAuth2Client) {\r\n        res.status(500).send('Authentication flow not properly initiated.');\r\n        return;\r\n      }\r\n      try {\r\n        const { tokens } = await this.flowOAuth2Client.getToken(code);\r\n        // Save tokens using the TokenManager (which uses the base client)\r\n        await this.tokenManager.saveTokens(tokens);\r\n        this.authCompletedSuccessfully = true;\r\n\r\n        // Get the path where tokens were saved\r\n        const tokenPath = this.tokenManager.getTokenPath();\r\n\r\n        // Send a more informative HTML response including the path\r\n        res.send(`\r\n          <!DOCTYPE html>\r\n          <html lang=\"en\">\r\n          <head>\r\n              <meta charset=\"UTF-8\">\r\n              <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n              <title>Authentication Successful</title>\r\n              <style>\r\n                  body { font-family: sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #f4f4f4; margin: 0; }\r\n                  .container { text-align: center; padding: 2em; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n                  h1 { color: #4CAF50; }\r\n                  p { color: #333; margin-bottom: 0.5em; }\r\n                  code { background-color: #eee; padding: 0.2em 0.4em; border-radius: 3px; font-size: 0.9em; }\r\n              </style>\r\n          </head>\r\n          <body>\r\n              <div class=\"container\">\r\n                  <h1>Authentication Successful!</h1>\r\n                  <p>Your authentication tokens have been saved successfully to:</p>\r\n                  <p><code>${tokenPath}</code></p>\r\n                  <p>You can now close this browser window.</p>\r\n              </div>\r\n          </body>\r\n          </html>\r\n        `);\r\n      } catch (error: unknown) {\r\n        this.authCompletedSuccessfully = false;\r\n        const message = error instanceof Error ? error.message : 'Unknown error';\r\n        // Send an HTML error response\r\n        res.status(500).send(`\r\n          <!DOCTYPE html>\r\n          <html lang=\"en\">\r\n          <head>\r\n              <meta charset=\"UTF-8\">\r\n              <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n              <title>Authentication Failed</title>\r\n              <style>\r\n                  body { font-family: sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #f4f4f4; margin: 0; }\r\n                  .container { text-align: center; padding: 2em; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n                  h1 { color: #F44336; }\r\n                  p { color: #333; }\r\n              </style>\r\n          </head>\r\n          <body>\r\n              <div class=\"container\">\r\n                  <h1>Authentication Failed</h1>\r\n                  <p>An error occurred during authentication:</p>\r\n                  <p><code>${message}</code></p>\r\n                  <p>Please try again or check the server logs.</p>\r\n              </div>\r\n          </body>\r\n          </html>\r\n        `);\r\n      }\r\n    });\r\n  }\r\n\r\n  async start(openBrowser = true): Promise<boolean> {\r\n    if (await this.tokenManager.validateTokens()) {\r\n      this.authCompletedSuccessfully = true;\r\n      return true;\r\n    }\r\n    \r\n    // Try to start the server and get the port\r\n    const port = await this.startServerOnAvailablePort();\r\n    if (port === null) {\r\n      this.authCompletedSuccessfully = false;\r\n      return false;\r\n    }\r\n\r\n    // Successfully started server on `port`. Now create the flow-specific OAuth client.\r\n    try {\r\n      const { client_id, client_secret } = await loadCredentials();\r\n      this.flowOAuth2Client = new OAuth2Client(\r\n        client_id,\r\n        client_secret,\r\n        `http://localhost:${port}/oauth2callback`\r\n      );\r\n    } catch (error) {\r\n        // Could not load credentials, cannot proceed with auth flow\r\n        this.authCompletedSuccessfully = false;\r\n        await this.stop(); // Stop the server we just started\r\n        return false;\r\n    }\r\n\r\n    if (openBrowser) {\r\n      // Generate Auth URL using the newly created flow client\r\n      const authorizeUrl = this.flowOAuth2Client.generateAuthUrl({\r\n        access_type: 'offline',\r\n        scope: ['https://www.googleapis.com/auth/calendar'],\r\n        prompt: 'consent'\r\n      });\r\n      await open(authorizeUrl);\r\n    }\r\n\r\n    return true; // Auth flow initiated\r\n  }\r\n\r\n  private async startServerOnAvailablePort(): Promise<number | null> {\r\n    for (let port = this.portRange.start; port <= this.portRange.end; port++) {\r\n      try {\r\n        await new Promise<void>((resolve, reject) => {\r\n          // Create a temporary server instance to test the port\r\n          const testServer = this.app.listen(port, () => {\r\n            this.server = testServer; // Assign to class property *only* if successful\r\n            resolve();\r\n          });\r\n          testServer.on('error', (err: NodeJS.ErrnoException) => {\r\n            if (err.code === 'EADDRINUSE') {\r\n              // Port is in use, close the test server and reject\r\n              testServer.close(() => reject(err)); \r\n            } else {\r\n              // Other error, reject\r\n              reject(err);\r\n            }\r\n          });\r\n        });\r\n        return port; // Port successfully bound\r\n      } catch (error: unknown) {\r\n        // Check if it's EADDRINUSE, otherwise rethrow or handle\r\n        if (!(error instanceof Error && 'code' in error && error.code === 'EADDRINUSE')) {\r\n            // An unexpected error occurred during server start\r\n            return null;\r\n        }\r\n        // EADDRINUSE occurred, loop continues\r\n      }\r\n    }\r\n    return null; // No port found\r\n  }\r\n\r\n  public getRunningPort(): number | null {\r\n    if (this.server) {\r\n      const address = this.server.address();\r\n      if (typeof address === 'object' && address !== null) {\r\n        return address.port;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  async stop(): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (this.server) {\r\n        this.server.close((err) => {\r\n          if (err) {\r\n            reject(err);\r\n          } else {\r\n            this.server = null;\r\n            resolve();\r\n          }\r\n        });\r\n      } else {\r\n        resolve();\r\n      }\r\n    });\r\n  }\r\n} ", "import { OAuth2Client, Credentials } from 'google-auth-library';\r\nimport * as fs from 'fs/promises';\r\nimport * as path from 'path';\r\nimport { getSecureTokenPath } from './utils.js';\r\nimport { GaxiosError } from 'gaxios';\r\n\r\nexport class TokenManager {\r\n  private oauth2Client: OAuth2Client;\r\n  private tokenPath: string;\r\n\r\n  constructor(oauth2Client: OAuth2Client) {\r\n    this.oauth2Client = oauth2Client;\r\n    this.tokenPath = getSecureTokenPath();\r\n    this.setupTokenRefresh();\r\n  }\r\n\r\n  // Method to expose the token path\r\n  public getTokenPath(): string {\r\n    return this.tokenPath;\r\n  }\r\n\r\n  private async ensureTokenDirectoryExists(): Promise<void> {\r\n    try {\r\n        const dir = path.dirname(this.tokenPath);\r\n        await fs.mkdir(dir, { recursive: true });\r\n    } catch (error: unknown) {\r\n        // Ignore errors if directory already exists, re-throw others\r\n        if (error instanceof Error && 'code' in error && error.code !== 'EEXIST') {\r\n            console.error('Failed to create token directory:', error);\r\n            throw error;\r\n        }\r\n    }\r\n  }\r\n\r\n  private setupTokenRefresh(): void {\r\n    this.oauth2Client.on(\"tokens\", async (newTokens) => {\r\n      try {\r\n        await this.ensureTokenDirectoryExists();\r\n        const currentTokens = JSON.parse(await fs.readFile(this.tokenPath, \"utf-8\"));\r\n        const updatedTokens = {\r\n          ...currentTokens,\r\n          ...newTokens,\r\n          refresh_token: newTokens.refresh_token || currentTokens.refresh_token,\r\n        };\r\n        await fs.writeFile(this.tokenPath, JSON.stringify(updatedTokens, null, 2), {\r\n          mode: 0o600,\r\n        });\r\n        console.error(\"Tokens updated and saved\");\r\n      } catch (error: unknown) {\r\n        // Handle case where currentTokens might not exist yet\r\n        if (error instanceof Error && 'code' in error && error.code === 'ENOENT') { \r\n          try {\r\n             await fs.writeFile(this.tokenPath, JSON.stringify(newTokens, null, 2), { mode: 0o600 });\r\n             console.error(\"New tokens saved\");\r\n          } catch (writeError) {\r\n            console.error(\"Error saving initial tokens:\", writeError);\r\n          }\r\n        } else {\r\n            console.error(\"Error saving updated tokens:\", error);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  async loadSavedTokens(): Promise<boolean> {\r\n    try {\r\n      await this.ensureTokenDirectoryExists();\r\n      if (\r\n        !(await fs\r\n          .access(this.tokenPath)\r\n          .then(() => true)\r\n          .catch(() => false))\r\n      ) {\r\n        console.error(\"No token file found at:\", this.tokenPath);\r\n        return false;\r\n      }\r\n\r\n      const tokens = JSON.parse(await fs.readFile(this.tokenPath, \"utf-8\"));\r\n\r\n      if (!tokens || typeof tokens !== \"object\") {\r\n        console.error(\"Invalid token format in file:\", this.tokenPath);\r\n        return false;\r\n      }\r\n\r\n      this.oauth2Client.setCredentials(tokens);\r\n      return true;\r\n    } catch (error: unknown) {\r\n      console.error(\"Error loading tokens:\", error);\r\n      // Attempt to delete potentially corrupted token file\r\n      if (error instanceof Error && 'code' in error && error.code !== 'ENOENT') { \r\n          try { \r\n              await fs.unlink(this.tokenPath); \r\n              console.error(\"Removed potentially corrupted token file\") \r\n            } catch (unlinkErr) { /* ignore */ } \r\n      }\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async refreshTokensIfNeeded(): Promise<boolean> {\r\n    const expiryDate = this.oauth2Client.credentials.expiry_date;\r\n    const isExpired = expiryDate\r\n      ? Date.now() >= expiryDate - 5 * 60 * 1000 // 5 minute buffer\r\n      : !this.oauth2Client.credentials.access_token; // No token means we need one\r\n\r\n    if (isExpired && this.oauth2Client.credentials.refresh_token) {\r\n      console.error(\"Auth token expired or nearing expiry, refreshing...\");\r\n      try {\r\n        const response = await this.oauth2Client.refreshAccessToken();\r\n        const newTokens = response.credentials;\r\n\r\n        if (!newTokens.access_token) {\r\n          throw new Error(\"Received invalid tokens during refresh\");\r\n        }\r\n        // The 'tokens' event listener should handle saving\r\n        this.oauth2Client.setCredentials(newTokens);\r\n        console.error(\"Token refreshed successfully\");\r\n        return true;\r\n      } catch (refreshError) {\r\n        if (refreshError instanceof GaxiosError && refreshError.response?.data?.error === 'invalid_grant') {\r\n            console.error(\"Error refreshing auth token: Invalid grant. Token likely expired or revoked. Please re-authenticate.\");\r\n            // Optionally clear the potentially invalid tokens here\r\n            // await this.clearTokens(); \r\n            return false; // Indicate failure due to invalid grant\r\n        } else {\r\n            // Handle other refresh errors\r\n            console.error(\"Error refreshing auth token:\", refreshError);\r\n            return false;\r\n        }\r\n      }\r\n    } else if (!this.oauth2Client.credentials.access_token && !this.oauth2Client.credentials.refresh_token) {\r\n        console.error(\"No access or refresh token available. Please re-authenticate.\");\r\n        return false;\r\n    } else {\r\n        // Token is valid or no refresh token available\r\n        return true;\r\n    }\r\n  }\r\n\r\n  async validateTokens(): Promise<boolean> {\r\n    if (!this.oauth2Client.credentials || !this.oauth2Client.credentials.access_token) {\r\n        // Try loading first if no credentials set\r\n        if (!(await this.loadSavedTokens())) {\r\n            return false; // No saved tokens to load\r\n        }\r\n        // Check again after loading\r\n        if (!this.oauth2Client.credentials || !this.oauth2Client.credentials.access_token) {\r\n            return false; // Still no token after loading\r\n        }\r\n    }\r\n    return this.refreshTokensIfNeeded();\r\n  }\r\n\r\n  async saveTokens(tokens: Credentials): Promise<void> {\r\n    try {\r\n        await this.ensureTokenDirectoryExists();\r\n        await fs.writeFile(this.tokenPath, JSON.stringify(tokens, null, 2), { mode: 0o600 });\r\n        this.oauth2Client.setCredentials(tokens);\r\n        console.error(\"Tokens saved successfully to:\", this.tokenPath);\r\n    } catch (error: unknown) {\r\n        console.error(\"Error saving tokens:\", error);\r\n        throw error;\r\n    }\r\n  }\r\n\r\n  async clearTokens(): Promise<void> {\r\n    try {\r\n      this.oauth2Client.setCredentials({}); // Clear in memory\r\n      await fs.unlink(this.tokenPath);\r\n      console.error(\"Tokens cleared successfully\");\r\n    } catch (error: unknown) {\r\n      if (error instanceof Error && 'code' in error && error.code === 'ENOENT') {\r\n        // File already gone, which is fine\r\n        console.error(\"Token file already deleted\");\r\n      } else {\r\n        console.error(\"Error clearing tokens:\", error);\r\n        // Don't re-throw, clearing is best-effort\r\n      }\r\n    }\r\n  }\r\n} ", "import { initializeOAuth2Client } from './auth/client.js';\r\nimport { AuthServer } from './auth/server.js';\r\n\r\n// Main function to run the authentication server\r\nasync function runAuthServer() {\r\n  let authServer: AuthServer | null = null; // Keep reference for cleanup\r\n  try {\r\n    // Initialize OAuth client\r\n    const oauth2Client = await initializeOAuth2Client();\r\n    \r\n    // Create and start the auth server\r\n    authServer = new AuthServer(oauth2Client);\r\n    \r\n    // Start with browser opening (true by default)\r\n    const success = await authServer.start(true);\r\n    \r\n    if (!success && !authServer.authCompletedSuccessfully) {\r\n      // Failed to start and tokens weren't already valid\r\n      process.stderr.write('Authentication failed. Could not start server or validate existing tokens. Check port availability (3000-3004) and try again.\\n');\r\n      process.exit(1);\r\n    } else if (authServer.authCompletedSuccessfully) {\r\n      // Auth was successful (either existing tokens were valid or flow completed just now)\r\n      process.stderr.write('Authentication successful.\\n');\r\n      process.exit(0); // Exit cleanly if auth is already done\r\n    }\r\n    \r\n    // If we reach here, the server started and is waiting for the browser callback\r\n    process.stderr.write('Authentication server started. Please complete the authentication in your browser...\\n');\r\n    \r\n    // Poll for completion or handle SIGINT\r\n    const pollInterval = setInterval(async () => {\r\n      if (authServer?.authCompletedSuccessfully) {\r\n        clearInterval(pollInterval);\r\n        await authServer.stop();\r\n        process.stderr.write('Authentication successful. Server stopped.\\n');\r\n        process.exit(0);\r\n      }\r\n    }, 1000); // Check every second\r\n\r\n    // Handle process termination (SIGINT)\r\n    process.on('SIGINT', async () => {\r\n      clearInterval(pollInterval); // Stop polling\r\n      if (authServer) {\r\n        await authServer.stop();\r\n      }\r\n      process.exit(0);\r\n    });\r\n    \r\n  } catch (error: unknown) {\r\n    process.stderr.write(`Authentication error: ${error instanceof Error ? error.message : 'Unknown error'}\\n`);\r\n    if (authServer) await authServer.stop(); // Attempt cleanup\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\n// Run the auth server if this file is executed directly\r\nif (import.meta.url.endsWith('auth-server.js')) {\r\n  runAuthServer().catch((error: unknown) => {\r\n    process.stderr.write(`Unhandled error: ${error instanceof Error ? error.message : 'Unknown error'}\\n`);\r\n    process.exit(1);\r\n  });\r\n}"],
  "mappings": "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",
  "names": ["OAuth2Client", "fs", "path", "OAuth2Client", "resolve"]
}
